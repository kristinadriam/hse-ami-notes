\section{Графы и базовый поиск в глубину}
\subsection{Определения}

\begin{definition}
    \textit{Граф} $G$ $-$ пара множеств вершин и рёбер $\langle V,\ E\rangle$. $V\ -$ множество вершин, $E\ -$ множество ребер (пар вершин).
\end{definition}

\begin{enumerate}
    \item[$$\circ$$] Вершины ещё иногда называют \textit{узлами}.
    \item[$\circ$] Если направление ребёр не имеет значение, граф \textit{неориентированный} (неорграф).
    \item[$\circ$] Если направление ребёр имеет значение, граф \textit{ориентированный} (орграф).
    \item[$\circ$] Если ребру дополнительно сопоставлен вес, то граф называют \textit{взвешенным}.
    \item[$\circ$] Рёбра в орграфе ещё называют \textit{дугами} и у ребра вводят понятие \textit{начало} и \textit{конец}.
    \item[$\circ$] Если $E$ – мультимножество, то могут быть равные рёбра, их называют \textit{кратными}.
    \item[$\circ$] Иногда, чтобы подчеркнуть, что $E$ – мультимножество, говорят \textit{мультиграф}.
    \item[$\circ$] Для ребра $e = (a,b)$, говорят, что $a$ \textit{инцидентно} вершине $b$.
    \item[$\circ$] \textit{Степень} вершины $a$ в неорграфе $\deg v$ – количество инцидентных ей рёбер.
    \item[$\circ$] В орграфе определяют ещё входящую и исходящую степени: $\deg v=\deg_{in} v + \deg_{out} v$.
    \item[$\circ$] Два ребра с общей вершиной называют \textit{смежными}.
    \item[$\circ$] Две вершины, соединённых ребром тоже называют \textit{смежными}.
    \item[$\circ$] Вершину степени ноль называют \textit{изолированной}.
    \item[$\circ$] Вершину степени один называют \textit{висячей} или \textit{листом}.
    \item[$\circ$] Ребро $(a,a)$ называют \textit{петлёй}.
    \item[$\circ$] \textit{Простым} будем называть граф без петель и кратных рёбер.
\end{enumerate}

\begin{definition}
    \textit{Путь} – чередующаяся последовательность вершин и рёбер, в которой соседние элементы инцидентны, а крайние – вершины. В орграфе направление всех рёбер от $i$ к $i+1$.
\end{definition}

\begin{enumerate}
    \item[$\circ$] Путь \textit{вершинно простой} или просто простой, если все вершины в нём различны.
    \item[$\circ$] Путь \textit{рёберно простой}, если все рёбра в нём различны.
    \item[$\circ$] Пути можно рассматривать и в неорграфах и в орграфах. Если в графе нет кратных рёбер, обычно путь задают только последовательностью вершин.
\end{enumerate}

\begin{remark}
    Иногда отдельно вводят понятие маршрута, цепи, простой цепи. Мы, чтобы не захламлять лексикон, ими пользоваться не будем.
\end{remark}

\begin{enumerate}
    \item[$\circ$] \textit{Цикл} $-$ путь с равными концами. Циклы тоже бывают вершинно и рёберно простыми.
    \item[$\circ$] \textit{Ацикличный граф} $-$ граф без циклов.
    \item[$\circ$] \textit{Дерево} $-$ ацикличный связный неорграф.
\end{enumerate}

\subsection{Хранение графа}
Будем обозначать $|V|=n,\ |E|=m$. Иногда сами $V$ и $E$ будут обозначать размеры.

\subsection*{Список ребер}

Можно просто хранить рёбра:
\lstinline!pair<int,int> edges[m];!
Чтобы в будущем удобно обрабатывать и взвешенные графы, и графы с потоком:

\begin{lstlisting}
     struct Edge {
        int from, to, weight;
    };
     Edge edges[m];
\end{lstlisting}

\subsection*{Матрица смежности}

Можно для каждой пары вершин хранить наличие ребра, или количество рёбер, или вес...

\lstinline!bool c[n][n];! для простого невзвешенного графа. $n^2$ бит памяти.

\lstinline!int c[n][n];! для простого взвешенного графа или незвешенного мультиграфа. $\mathcal{O}(n^2)$ памяти.

\lstinline!vector<int> c[n][n];! для взвешенного мультиграфа придётся хранить список всех весов всех рёбер между парой вершин.

\lstinline!vector<vector<bool>> c(n, vector<bool>(n));! – чтобы первый способ правда весил $n^2$ бит. Константа времени работы увеличится (нужно достать определённый бит 32-битного числа).

\subsection*{Списки смежности}

Можно для каждой вершины хранить список инцидентных ей рёбер: \lstinline!vector<Edge> c[n];!
Чтобы списки смежности умели быстро удалять, заменяем \lstinline!vector! на \lstinline!set/unordered\_set!.

\subsection*{Список ребер}

\subsection*{Сравнение способов хранения}
Основных действий, которых нам нужно будет проделывать с графом не так много:
\begin{enumerate}
    \item\lstinline!adjacent(v)! – перебрать все инцидентные $v$ ребра.
    \item\lstinline!get(a,b)! – посмотреть на наличие/вес ребра между $a$ и $b$.
    \item\lstinline!all! - просмотреть все рёбра графа.
    \item\lstinline!add(a,b)!–добавить ребро в граф.
    \item\lstinline!del(a,b)! – удалить ребро из графа.
\end{enumerate}
Ещё важно оценить дополнительную память.
\begin{table}[]
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        & \lstinline!adjacent! & \lstinline!get! &\lstinline!all! & \lstinline!add! & \lstinline!del! & memory \\
        \hline
        Список ребер & $\mathcal{O}(E)$ & $\mathcal{O}(E)$ & $\mathcal{O}(E)$ & $\mathcal{O}(1)$ & $\mathcal{O}(E)$ & $\mathcal{O}(E)$ \\
        \hline
        Матрица смежности & $\mathcal{O}(1)$ & $\mathcal{O}(1)$ & $\mathcal{O}(V^2)$ & $\mathcal{O}(1)$ & $\mathcal{O}(1)$ & $\mathcal{O}(V^2)$ \\
        \hline
        Списки смежности (vector) & $\mathcal{O}(deg)$ & $\mathcal{O}(deg)$ & $\mathcal{O}(V+E)$ & $\mathcal{O}(1)$ & $\mathcal{O}(deg)$ & $\mathcal{O}(E)$ \\
        \hline
        Списки смежности (hashTable) & $\mathcal{O}(deg)$ & $\mathcal{O}(1)$ & $\mathcal{O}(V+E)$ & $\mathcal{O}(1)$ & $\mathcal{O}(1)$ & $\mathcal{O}(E)$ \\
        \hline
    \end{tabular}
\end{table}

Единственные плюсы первого способа – не нужна доппамять; в таком виде удобно хранить граф в файле (чтобы добавить одно ребро, допишем его в конец файла).
Если матрица смежности уж слишком велика, можно хранить хеш-таблицу $\langle a,b\rangle\rightarrow c[a,b]$.
В большинстве задач граф хранят списками смежности (иногда с \lstinline!set! вместо \lstinline!vector!).

\textbf{Пример задачи}, которую хорошо решает матрица смежности: даны граф и последовательность вершин в нём, проверить, что она – простой путь.

\textbf{Пример задачи}, которую хорошо решают списки смежности: пометить все вершины, смежные с $v$.

\textbf{Пример задачи}, где нужна сила обеих структур: даны две смежные вершины, найти третью, чтобы получился треугольник.

\subsection*{Мультисписок}
Рёбра, смежные с $v$, лежат в односвязном списке \lstinline!head[v], next[head[v]], next[next[head[v]]]!... Все перечисленные элементы – номера рёбер.

По номеру ребра $e$ можем хранить любую информацию про него, например, куда оно ведёт.

\begin{lstlisting}
    struct MultiList {
        struct Edge { int next, to; };
        vector<int> head; // first edge for every vertex
        vector <Edge > es; // all edges
        int e; // amount of edges
        MultiList(int n, int m) :
            head(n, -1), // -1 is a sign of the enf of the list
            e s ( m ) , // max amount of edges
            e = 0 { } // there is no edges at the start
        void addEdge(int a, int b) { // one directed edge
            es[e] = {head[a], b}, head[a] = e++;
        }
        void adjacent(int v) { // all connected with v edges
        for (int e = head[v]; e != -1; e = es[e].next)
            cout << es[e].next << " "; // or anything else
        }
    };
\end{lstlisting}

По сути эти те же «списки смежности», но более аккуратно сохранённые.

Пусть $V=E=10^6$, граф случайный. Оценим память.
На 64-битной машине \lstinline!vector<vector<int> g! будет в итоге весить $X = ?_1 = 3 \cdot 8 + ?_2$ мегабайта (сам по себе вектор – 3 указателя). Можно подумать, что $?_2 = E \cdot 4$, но нет, в векторе size $\neq$ capacity $\Rightarrow$ нужно проводить эксперимент. На двух экспериментах видим, что $?_2 \approx E \cdot 12$ и $E\cdot 16$. Итого $X\approx 36-38$  мегабайт.
А мультисписок 12 = 3·4 мегабайта. Итого разница в $\approx$ 3 раза. По скорости создания/удаления (выделить память, положить все элементы, освободить память) мультисписок будет в $\approx$ 10 раз быстрее.

\subsection{Поиск в глубину}
Поиск в глубину = \textit{depth-first-search} = dfs.

\textbf{Задача:} пометить все вершины, достижимые из $a$.

\textbf{Решение:} рекурсивно вызываемся от всех соседей $a$.

\begin{lstlisting}
    vector<vector<int>> g(n);
    void dfs(int v) {
        used[v] = true;
        for (int u : g[v])
            p[u] = v, dfs(u);
    }

    dfs(v);
\end{lstlisting}

Время работы $\mathcal{O}(E)$, так как по каждому ребру dfs проходит не более одного раза.

Для восстановления пути из вершины $v$ в вершину $u$ достаточно хранить массив предков, где для каждой вершины, хранится номер вершины, из которой мы пришли. У стартовой $p[v]=-1$.

Немного его модифицируем, а именно будем сохранять для каждой вершины, в какой момент мы в неё вошли и в какой вышли — соответствующие массивы будем называть $tin$ и $tout$.

Как их заполнить: заведем таймер, отвечающий за «время» на текущем состоянии обхода, и будем инкрементировать его каждый раз, когда заходим в новую вершину:

\begin{lstlisting}
    std::vector<int> tin(n), tout(n);
    int t = 0; // timer

    void dfs(int v) {
        tin[v] = t++;
        for (int u : g[v])
            if (!used[u])
                dfs(u);
        tout[v] = t;
}
\end{lstlisting}

Полезные свойства этих массивов:
\begin{enumerate}
    \item Вершина u является предком $v\Leftrightarrowtin_v\in[tin_u, tout_u) $. Эту проверку можно делать за константу.
    \item Два полуинтервала $[tin_u, tout_u)$ и $[tin_v, tout_v)$ либо не пересекаются, либо один вложен в другой.
    \item В массиве $tin$ есть все числа от 0 до $(n-1)$, причём у каждой вершины свой номер.
    \item Размер поддерева вершины $v$ (включая саму вершину) равен $(tout_v-tin_v)$.
    \item Если ввести нумерацию вершин, соответствующую $tin$-ам, то индексы любого поддерева всегда будут каким-то промежутком в этой нумерации.
\end{enumerate}

\subsection{Компоненты связности}

\begin{definition}
    Две вершины $u$ и $v$ называются \textit{связанными} (adjacent), если в графе $G$ существует путь из $u$ в $v$ (обозначение: $u\leadsto v$).
\end{definition}

\begin{definition}
    \textit{Компонентой связности неориентированного графа} называется подмножество вершин, достижимых из какой-то заданной вершины.
\end{definition}

\begin{theorem}
    Связанность $-$ отношение эквивалентности.
\end{theorem}

\begin{proof}
    Рефлексивность: $\forall a \in V\ a\leadsto a$.

    Симметричность: $a\leadsto b \Rightarrow b\leadsto a$ (в силу неориентированности).

    Транзитивность: $a\leadsto b \wedge b\leadsto c\Rightarrow a\leadsto c$

    Действительно, сначала пройдем от $a$ до $b$, затем от $b$ до $c$, что и означает существования пути $a\leadsto c$.
\end{proof}

\subsection*{Поиск компонент связности}

Для решения задачи модифицируем обход в глубину так, чтобы запустившись от вершины какой-то компоненты, от пометил все вершины этой компоненты — то есть все достижимые вершины — заданным номером этой компоненты.

\begin{lstlisting}
    void dfs(int v, int col) {
        used[v] = col;
        for (int u : g[v])
            if (!used[v])
                p[u] = v, dfs(u, col);
    }

    int comp = 0;
    for (int v = 0; v < n; v++)
        if (!used[v])
            dfs(v, ++comp);
\end{lstlisting}

Итоговая асимптотика составит $\mathcal{O}(V+E)$, потому что такой алгоритм не будет запускаться от одной и той же вершины дважды, и каждое ребро будет просмотрено ровно два раза (с одного конца и с другого).

\subsection{Классификация рёбер}
После dfs(v) остаётся дерево с корнем в $v$. Отец вершины $u$ – та, из которой мы пришли в $v$. Пусть все вершины достижимы из $v$. Рёбра разбились на следующие классы:
\begin{enumerate}
    \item Древесные: принадлежат дереву.
    \item Прямые: идут вниз по дереву.
    \item Обратные: идут вверх по дереву.
    \item Перекрёстные: идут между разными поддеревьями.
\end{enumerate}

Рёбра можно классифицировать относительно любого корневого дерева, но именно относителmно дерева, полученного dfs в неорграфе, нет перекрёстных рёбер.

\begin{lemma}
    Относительно дерева dfs неорграфа нет перекрёстных рёбер.
\end{lemma}

\begin{proof}
    Если есть перекрёстное ребро $a\rightarrow b$, есть и $b\rightarrow a$ (граф неориентированный). Пусть $tin_a<tin)b$. $a\rightarrow b$ перекрёстное $\Rightarrow tin_b>tout_a$. Противоречие с тем, что dfs пытался пройти по ребру $a\rightarrow b$.
\end{proof}

\subsection{Топологическая сортировка}
\begin{definition}
    Топологической сортировкой орграфа называется сопоставление вершинам номеров $ind[v]:\forall (a\rightarrow b)\ ind\_a<ind\_b$.

\end{definition}
\begin{lemma}
    Топологическая сортировка существует тогда и только тогда, когда граф ацикличен.
\end{lemma}

\begin{proof}
    Если есть цикл, то рассмотрим неравенства по циклу и получим противоречие.

    Если цикла нет, то сещствует вершина нулевой входящей степени, сопоставим ей $ind[v]=0$, удалим ее из графа, граф останется ациклинчым, по индукции нумеруем оставшиеся вершины.
\end{proof}

В процессе доказательства получили нерекурсивный алгоритм топологической сортировки за $\mathcal{O}(V+E)$: поддерживаем входящие степени и очереди вершин нулевой входящей степени. Итенрация:

\begin{lstlisting}
    v = q.pop();
    topsort.push_back(v);
    for (int u : g[v])
        if (--dex[u] == 0)
            q.push(u);
;\end{lstlisting}

\subsection*{Алгоритм топологической сортировки}
dfs умеет сортировать вершины по времени входа и времени выхода.

\begin{lstlisting}
    void dfs(int v) {
        in_time_order.push_back(v);
        ...
        out_time_order.push_back(v);
    }
\end{lstlisting}

Топологический порядок вершин записан в \lstinline!reverse(out_time_order)!.

\begin{proof}
    Пусть есть ребро $a\rightarrow b$, тогда мы сперва выйдем из $b$ и тоолько затем из $a$.
\end{proof}